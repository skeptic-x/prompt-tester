<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prompt Tester</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; min-height: 100vh; }
    
    .header { background: #fff; padding: 16px 24px; border-bottom: 1px solid #e0e0e0; display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .header input[type="password"] { flex: 1; min-width: 200px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; }
    .header select { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; background: #fff; }
    .header .status { font-size: 12px; color: #666; }
    .header .status.ready { color: #22c55e; }
    
    .container { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 16px; max-width: 1600px; margin: 0 auto; }
    
    .panel { background: #fff; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; }
    .panel-header { padding: 12px 16px; border-bottom: 1px solid #eee; font-weight: 600; color: #333; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; }
    
    .system-prompt { padding: 12px; border-bottom: 1px solid #eee; }
    .system-prompt label { font-size: 12px; color: #666; display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .system-prompt textarea { width: 100%; height: 80px; padding: 10px; border: 1px solid #e0e0e0; border-radius: 6px; font-size: 13px; resize: vertical; font-family: inherit; }
    .max-tokens { width: 70px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
    
    .chat-area { flex: 1; min-height: 300px; max-height: 50vh; overflow-y: auto; padding: 16px; }
    .message { margin-bottom: 12px; padding: 10px 14px; border-radius: 8px; font-size: 14px; line-height: 1.5; white-space: pre-wrap; }
    .message.user { background: #e3f2fd; margin-left: 20%; }
    .message.assistant { background: #f5f5f5; margin-right: 20%; }
    .message.error { background: #ffebee; color: #c62828; }
    .message.loading { color: #888; font-style: italic; }
    
    .input-area { padding: 16px; background: #fafafa; border-top: 1px solid #eee; }
    .input-row { display: flex; gap: 8px; }
    .input-area textarea { flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; height: 60px; font-family: inherit; }
    .input-area button { padding: 12px 24px; background: #2563eb; color: #fff; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500; }
    .input-area button:hover { background: #1d4ed8; }
    .input-area button:disabled { background: #ccc; cursor: not-allowed; }
    .input-area button.secondary { background: #6b7280; }
    .input-area button.secondary:hover { background: #4b5563; }
    
    .checkbox-a, .checkbox-b { display: flex; align-items: center; gap: 4px; padding: 8px 12px; border-radius: 6px; font-weight: 600; cursor: pointer; user-select: none; }
    .checkbox-a { background: #dcfce7; color: #166534; }
    .checkbox-b { background: #ede9fe; color: #5b21b6; }
    .checkbox-a input, .checkbox-b input { cursor: pointer; }
    
    .model-select { padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; background: #fff; margin: 0 8px; }
    
    .panel-header span { font-size: 11px; color: #059669; font-weight: 500; background: #ecfdf5; padding: 3px 8px; border-radius: 4px; }
    .panel-header .msg-count { background: #e0e7ff; color: #4338ca; }

    .message { position: relative; }
    .message.user .edit-btn { display: none; position: absolute; right: 8px; top: 8px; background: transparent; border: none; cursor: pointer; font-size: 12px; color: #666; padding: 2px 6px; border-radius: 4px; }
    .message.user .edit-btn:hover { background: #ddd; }
    .message.user:hover .edit-btn { display: block; }

    .full-width { grid-column: 1 / -1; }
    
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="header">
    <input type="password" id="apiKey" placeholder="Paste OpenAI API Key (stored locally in browser)">
    <span class="status" id="status">âšª Enter API key</span>
  </div>

  <div class="container">
    <div class="panel">
      <div class="panel-header">
        Prompt A 
        <select id="modelA" class="model-select">
          <option value="gpt-5-nano">gpt-5-nano ($0.05/$0.40)</option>
          <option value="gpt-4.1-nano">gpt-4.1-nano ($0.10/$0.40)</option>
          <option value="gpt-4o-mini">gpt-4o-mini ($0.15/$0.60)</option>
          <option value="gpt-4.1-mini">gpt-4.1-mini ($0.40/$1.60)</option>
        </select>
        <span id="msgCountA" class="msg-count"></span>
        <span id="tokensA"></span>
      </div>
      <div class="system-prompt">
        <label>System Prompt <input type="number" id="maxTokensA" class="max-tokens" value="256" min="1" max="4096" title="Max tokens"></label>
        <textarea id="systemA" placeholder="You are a helpful assistant..."></textarea>
      </div>
      <div class="chat-area" id="chatA"></div>
    </div>

    <div class="panel">
      <div class="panel-header">
        Prompt B 
        <select id="modelB" class="model-select">
          <option value="gpt-5-nano">gpt-5-nano ($0.05/$0.40)</option>
          <option value="gpt-4.1-nano">gpt-4.1-nano ($0.10/$0.40)</option>
          <option value="gpt-4o-mini">gpt-4o-mini ($0.15/$0.60)</option>
          <option value="gpt-4.1-mini">gpt-4.1-mini ($0.40/$1.60)</option>
        </select>
        <span id="msgCountB" class="msg-count"></span>
        <span id="tokensB"></span>
      </div>
      <div class="system-prompt">
        <label>System Prompt <input type="number" id="maxTokensB" class="max-tokens" value="256" min="1" max="4096" title="Max tokens"></label>
        <textarea id="systemB" placeholder="You are a helpful assistant..."></textarea>
      </div>
      <div class="chat-area" id="chatB"></div>
    </div>

    <div class="input-area full-width">
      <div class="input-row">
        <textarea id="userInput" placeholder="Type your message... (Enter to send, Shift+Enter for newline)"></textarea>
        <label class="checkbox-a"><input type="checkbox" id="targetA" checked> A</label>
        <label class="checkbox-b"><input type="checkbox" id="targetB" checked> B</label>
        <button onclick="sendMessage()">Send</button>
        <button class="secondary" onclick="clearChats()">Clear</button>
        <button class="secondary" onclick="retryLast()">Retry</button>
      </div>
    </div>
  </div>

  <script>
    const historyA = [];
    const historyB = [];
    let lastUserMessage = '';
    let lastTarget = { a: true, b: true };

    // Pricing per 1M tokens (Standard tier)
    const PRICING = {
      'gpt-5-nano':   { input: 0.05,  output: 0.40 },
      'gpt-4.1-nano': { input: 0.10,  output: 0.40 },
      'gpt-4o-mini':  { input: 0.15,  output: 0.60 },
      'gpt-4.1-mini': { input: 0.40,  output: 1.60 }
    };

    // Running totals
    let totalCostA = 0, totalCostB = 0;
    let totalInputA = 0, totalOutputA = 0;
    let totalInputB = 0, totalOutputB = 0;

    function calculateCost(model, promptTokens, completionTokens) {
      const prices = PRICING[model] || { input: 0, output: 0 };
      const inputCost = (promptTokens / 1_000_000) * prices.input;
      const outputCost = (completionTokens / 1_000_000) * prices.output;
      return inputCost + outputCost;
    }

    function formatCost(cost) {
      if (cost < 0.0001) return '<$0.0001';
      if (cost < 0.01) return '$' + cost.toFixed(4);
      return '$' + cost.toFixed(3);
    }

    function updateMsgCount() {
      const countA = historyA.filter(m => m.role === 'user').length;
      const countB = historyB.filter(m => m.role === 'user').length;
      document.getElementById('msgCountA').textContent = countA ? `${countA} msg` : '';
      document.getElementById('msgCountB').textContent = countB ? `${countB} msg` : '';
    }

    // Load saved API key and prompts
    document.getElementById('apiKey').value = localStorage.getItem('openai_key') || '';
    document.getElementById('systemA').value = localStorage.getItem('systemA') || 'You are a helpful assistant.';
    document.getElementById('systemB').value = localStorage.getItem('systemB') || 'You are a helpful assistant.';
    document.getElementById('modelA').value = localStorage.getItem('modelA') || 'gpt-5-nano';
    document.getElementById('modelB').value = localStorage.getItem('modelB') || 'gpt-5-nano';
    updateStatus();

    // Save on change
    document.getElementById('apiKey').addEventListener('input', (e) => {
      localStorage.setItem('openai_key', e.target.value);
      updateStatus();
    });
    document.getElementById('systemA').addEventListener('input', (e) => {
      localStorage.setItem('systemA', e.target.value);
    });
    document.getElementById('systemB').addEventListener('input', (e) => {
      localStorage.setItem('systemB', e.target.value);
    });
    document.getElementById('modelA').addEventListener('change', (e) => {
      localStorage.setItem('modelA', e.target.value);
    });
    document.getElementById('modelB').addEventListener('change', (e) => {
      localStorage.setItem('modelB', e.target.value);
    });

    // Enter to send
    document.getElementById('userInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    function getTargets() {
      return {
        a: document.getElementById('targetA').checked,
        b: document.getElementById('targetB').checked
      };
    }

    function updateStatus() {
      const status = document.getElementById('status');
      if (document.getElementById('apiKey').value) {
        status.textContent = 'ðŸŸ¢ Ready';
        status.className = 'status ready';
      } else {
        status.textContent = 'âšª Enter API key';
        status.className = 'status';
      }
    }

    function addMessage(chatId, role, content, msgIndex = null) {
      const chat = document.getElementById(chatId);
      const div = document.createElement('div');
      div.className = `message ${role}`;
      div.textContent = content;
      
      // Add edit button to user messages
      if (role === 'user') {
        const editBtn = document.createElement('button');
        editBtn.className = 'edit-btn';
        editBtn.textContent = 'âœï¸';
        editBtn.onclick = () => editMessage(chatId, msgIndex, content);
        div.appendChild(editBtn);
        div.dataset.msgIndex = msgIndex;
      }
      
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
      return div;
    }

    function editMessage(chatId, msgIndex, content) {
      const panel = chatId === 'chatA' ? 'a' : 'b';
      const history = chatId === 'chatA' ? historyA : historyB;
      const chat = document.getElementById(chatId);
      
      // Remove all messages from this index onwards
      const toRemove = [];
      chat.querySelectorAll('.message').forEach(el => {
        const idx = parseInt(el.dataset.msgIndex);
        if (!isNaN(idx) && idx >= msgIndex) toRemove.push(el);
        // Also remove assistant messages that came after
        if (el.previousElementSibling?.dataset.msgIndex >= msgIndex && !el.dataset.msgIndex) {
          toRemove.push(el);
        }
      });
      
      // Simpler approach: remove messages from DOM starting at msgIndex
      const allMsgs = Array.from(chat.querySelectorAll('.message'));
      let startRemoving = false;
      allMsgs.forEach(el => {
        if (el.dataset.msgIndex == msgIndex) startRemoving = true;
        if (startRemoving) el.remove();
      });
      
      // Truncate history to before this message
      const historyIndex = msgIndex * 2; // Each exchange is 2 messages (user + assistant)
      history.length = historyIndex;
      
      // Put content in input for editing
      document.getElementById('userInput').value = content;
      document.getElementById('userInput').focus();
      
      updateMsgCount();
    }

    async function callOpenAI(systemPrompt, history, model, maxTokens, onChunk) {
      const apiKey = document.getElementById('apiKey').value;
      const messages = [
        { role: 'system', content: systemPrompt },
        ...history
      ];

      console.log(`[API] Calling ${model} with ${messages.length} messages, max_tokens=${maxTokens} (streaming)`);
      const startTime = Date.now();

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({ model, messages, max_tokens: parseInt(maxTokens), stream: true })
      });

      if (!response.ok) {
        const err = await response.json();
        throw new Error(err.error?.message || 'API error');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let content = '';
      let promptTokens = 0, completionTokens = 0;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n').filter(l => l.startsWith('data: '));

        for (const line of lines) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;
          
          try {
            const parsed = JSON.parse(data);
            const delta = parsed.choices[0]?.delta?.content || '';
            if (delta) {
              content += delta;
              onChunk(content);
            }
            // Capture usage from final chunk if present
            if (parsed.usage) {
              promptTokens = parsed.usage.prompt_tokens || 0;
              completionTokens = parsed.usage.completion_tokens || 0;
            }
          } catch (e) {}
        }
      }

      console.log(`[API] ${model} streamed in ${Date.now() - startTime}ms`);
      return { content, promptTokens, completionTokens, totalTokens: promptTokens + completionTokens };
    }

    async function sendMessage() {
      const input = document.getElementById('userInput');
      const message = input.value.trim();
      if (!message) return;

      const targets = getTargets();
      if (!targets.a && !targets.b) return; // Nothing selected

      lastUserMessage = message;
      lastTarget = targets;
      input.value = '';

      const modelA = document.getElementById('modelA').value;
      const modelB = document.getElementById('modelB').value;
      const systemA = document.getElementById('systemA').value;
      const systemB = document.getElementById('systemB').value;
      const maxTokensA = document.getElementById('maxTokensA').value || 256;
      const maxTokensB = document.getElementById('maxTokensB').value || 256;

      const sendToA = targets.a;
      const sendToB = targets.b;

      // Get message index for edit tracking
      const msgIndexA = historyA.filter(m => m.role === 'user').length;
      const msgIndexB = historyB.filter(m => m.role === 'user').length;

      // Add user message
      if (sendToA) {
        addMessage('chatA', 'user', message, msgIndexA);
        historyA.push({ role: 'user', content: message });
      }
      if (sendToB) {
        addMessage('chatB', 'user', message, msgIndexB);
        historyB.push({ role: 'user', content: message });
      }
      
      updateMsgCount();

      // Loading indicators
      const loadingA = sendToA ? addMessage('chatA', 'loading', 'Thinking...') : null;
      const loadingB = sendToB ? addMessage('chatB', 'loading', 'Thinking...') : null;

      document.querySelectorAll('.input-area button').forEach(b => b.disabled = true);

      // Handle A
      if (sendToA) {
        loadingA.remove();
        const msgDivA = addMessage('chatA', 'assistant', '');
        try {
          const resultA = await callOpenAI(systemA, historyA, modelA, maxTokensA, (text) => {
            msgDivA.textContent = text;
            document.getElementById('chatA').scrollTop = document.getElementById('chatA').scrollHeight;
          });
          historyA.push({ role: 'assistant', content: resultA.content });
          const cost = calculateCost(modelA, resultA.promptTokens, resultA.completionTokens);
          totalCostA += cost;
          totalInputA += resultA.promptTokens;
          totalOutputA += resultA.completionTokens;
          document.getElementById('tokensA').textContent = `â†‘${totalInputA} â†“${totalOutputA} Â· ${formatCost(totalCostA)}`;
        } catch (e) {
          msgDivA.className = 'message error';
          msgDivA.textContent = e.message;
        }
      }

      // Handle B
      if (sendToB) {
        loadingB.remove();
        const msgDivB = addMessage('chatB', 'assistant', '');
        try {
          const resultB = await callOpenAI(systemB, historyB, modelB, maxTokensB, (text) => {
            msgDivB.textContent = text;
            document.getElementById('chatB').scrollTop = document.getElementById('chatB').scrollHeight;
          });
          historyB.push({ role: 'assistant', content: resultB.content });
          const cost = calculateCost(modelB, resultB.promptTokens, resultB.completionTokens);
          totalCostB += cost;
          totalInputB += resultB.promptTokens;
          totalOutputB += resultB.completionTokens;
          document.getElementById('tokensB').textContent = `â†‘${totalInputB} â†“${totalOutputB} Â· ${formatCost(totalCostB)}`;
        } catch (e) {
          msgDivB.className = 'message error';
          msgDivB.textContent = e.message;
        }
      }

      document.querySelectorAll('.input-area button').forEach(b => b.disabled = false);
    }

    function clearChats() {
      const targets = getTargets();
      
      if (targets.a) {
        document.getElementById('chatA').innerHTML = '';
        document.getElementById('tokensA').textContent = '';
        document.getElementById('msgCountA').textContent = '';
        historyA.length = 0;
        totalCostA = 0;
        totalInputA = 0; totalOutputA = 0;
      }
      
      if (targets.b) {
        document.getElementById('chatB').innerHTML = '';
        document.getElementById('tokensB').textContent = '';
        document.getElementById('msgCountB').textContent = '';
        historyB.length = 0;
        totalCostB = 0;
        totalInputB = 0; totalOutputB = 0;
      }
    }

    function retryLast() {
      if (!lastUserMessage || !lastTarget) return;
      const sendToA = lastTarget.a;
      const sendToB = lastTarget.b;
      
      // Remove last exchange from A
      if (sendToA && historyA.length >= 2) {
        historyA.pop(); historyA.pop();
        const chatA = document.getElementById('chatA');
        chatA.lastChild?.remove(); chatA.lastChild?.remove();
      }
      // Remove last exchange from B
      if (sendToB && historyB.length >= 2) {
        historyB.pop(); historyB.pop();
        const chatB = document.getElementById('chatB');
        chatB.lastChild?.remove(); chatB.lastChild?.remove();
      }
      updateMsgCount();
      document.getElementById('userInput').value = lastUserMessage;
      
      // Restore checkbox state to match last send
      document.getElementById('targetA').checked = sendToA;
      document.getElementById('targetB').checked = sendToB;
      
      sendMessage();
    }
  </script>
</body>
</html>
